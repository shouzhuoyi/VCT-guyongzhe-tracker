<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>VCT Tracker - Archived Stats</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background: #f2f2f2; font-family: sans-serif; }
        .vlr-table { border-collapse: collapse; width: 100%; font-size: 13px; background: white; margin-bottom: 24px; table-layout: auto; }
        
        /* Draggable Headers */
        .vlr-table th { 
            color: #7a7a7a; padding: 12px 6px; border-bottom: 1px solid #eee; 
            font-weight: normal; cursor: grab; user-select: none; 
            transition: background 0.2s; white-space: nowrap; 
        }
        .vlr-table th:active { cursor: grabbing; }
        .vlr-table th.dragging { opacity: 0.5; background: #e0f7fa; border: 2px dashed #2979ff; }
        .vlr-table th.drag-over { border-left: 3px solid #2979ff; } /* Indicator */

        .vlr-table th:hover { background-color: #f0f0f0; color: #333; font-weight: bold; }
        
        .vlr-table td { padding: 8px 6px; border-bottom: 1px solid #eee; text-align: center; vertical-align: middle; }
        
        /* Specific Styles */
        .cell-player { text-align: left !important; padding-left: 12px !important; min-width: 140px; }
        .cell-team { text-align: left !important; color: #999; font-size: 11px; display: block; }
        .cell-agents { min-width: 180px; max-width: 300px; } 
        
        /* Agent Layout */
        .agent-container { display: flex; flex-wrap: wrap; gap: 4px; justify-content: flex-start; }
        .agent-icon { width: 20px; height: 20px; }
    </style>
</head>
<body>
    {{{header}}}

    <div class="max-w-[95%] mx-auto p-4">
        <h1 class="text-2xl font-bold mb-4">Archived Players (Drag Headers to Reorder)</h1>
        
        <div class="overflow-x-auto">
            <table class="vlr-table shadow-sm" id="statsTable">
                <thead>
                    <tr id="headerRow">
                        <!-- Default Order -->
                        <th data-key="name" class="cell-player" draggable="true">PLAYER</th>
                        <th data-key="agents" class="cell-agents" draggable="true">AGENTS</th>
                        <th data-key="rounds" draggable="true">RND</th>
                        <th data-key="rating" draggable="true">R</th>
                        <th data-key="acs" draggable="true">ACS</th>
                        <th data-key="k" draggable="true">K</th>
                        <th data-key="d" draggable="true">D</th>
                        <th data-key="a" draggable="true">A</th>
                        <th data-key="kd" draggable="true">K/D</th>
                        <th data-key="kast" draggable="true">KAST</th>
                        <th data-key="adr" draggable="true">ADR</th>
                        <th data-key="kpr" draggable="true">KPR</th>
                        <th data-key="apr" draggable="true">APR</th>
                        <th data-key="fkpr" draggable="true">FKPR</th>
                        <th data-key="fdpr" draggable="true">FDPR</th>
                        <th data-key="hs" draggable="true">HS%</th>
                    </tr>
                </thead>
                <tbody id="tableBody">
                    <!-- JS handles rendering -->
                </tbody>
            </table>
        </div>
    </div>

    <script>
        const playersData = {{{jsonPlayers}}};
        
        // Initial Column Order
        let columns = [
            'name', 'agents', 'rounds', 'rating', 'acs', 
            'k', 'd', 'a', 'kd', 'kast', 
            'adr', 'kpr', 'apr', 'fkpr', 'fdpr', 'hs'
        ];
        
        // Sorting State
        let sortState = { key: 'rating', dir: 'desc' };

        // Heatmap Config
        const heatMapCols = {
            'rating': { min: 0, max: 0 },
            'acs':    { min: 0, max: 0 },
            'k':      { min: 0, max: 0 },
            'd':      { min: 0, max: 0, isReverse: true },
            'a':      { min: 0, max: 0 },
            'kd':     { min: 0, max: 0 },
            'kast':   { min: 0, max: 0 },
            'adr':    { min: 0, max: 0 },
            'kpr':    { min: 0, max: 0 },
            'apr':    { min: 0, max: 0 },
            'fkpr':   { min: 0, max: 0 },
            'fdpr':   { min: 0, max: 0, isReverse: true },
            'hs':     { min: 0, max: 0 }
        };

        function initStats() {
            Object.keys(heatMapCols).forEach(k => {
                heatMapCols[k].min = Infinity;
                heatMapCols[k].max = -Infinity;
            });

            playersData.forEach(p => {
                Object.keys(heatMapCols).forEach(k => {
                    let val = parseFloat(p[k]) || 0;
                    if (val < heatMapCols[k].min) heatMapCols[k].min = val;
                    if (val > heatMapCols[k].max) heatMapCols[k].max = val;
                });
            });
        }

        function getColorStyle(key, value) {
            const config = heatMapCols[key];
            if (!config || config.max === config.min) return '';

            let ratio = (value - config.min) / (config.max - config.min);
            if (config.isReverse) ratio = 1 - ratio;

            // Simplified Gradient Logic
            const anchors = [
                [1.0, [194, 172, 223]],
                [0.8, [173, 216, 230]],
                [0.6, [180, 238, 180]],
                [0.4, [255, 255, 180]],
                [0.2, [255, 218, 185]],
                [0.0, [218, 173, 198]]
            ];

            let r, g, b;
            for (let i = 0; i < anchors.length - 1; i++) {
                const upper = anchors[i];
                const lower = anchors[i+1];
                if (ratio >= lower[0]) {
                    const range = upper[0] - lower[0];
                    const localRatio = (ratio - lower[0]) / range;
                    r = Math.round(lower[1][0] + (upper[1][0] - lower[1][0]) * localRatio);
                    g = Math.round(lower[1][1] + (upper[1][1] - lower[1][1]) * localRatio);
                    b = Math.round(lower[1][2] + (upper[1][2] - lower[1][2]) * localRatio);
                    break;
                }
            }
            return `style="background-color: rgb(${r}, ${g}, ${b});"`;
        }

        function sortData(key) {
            if (sortState.key === key) {
                sortState.dir = sortState.dir === 'desc' ? 'asc' : 'desc';
            } else {
                sortState.key = key;
                sortState.dir = 'desc';
            }
            const dir = sortState.dir === 'desc' ? 1 : -1;
            
            playersData.sort((a, b) => {
                let valA = parseFloat(a[key]) || 0;
                let valB = parseFloat(b[key]) || 0;
                
                // Agents and Name are special cases for sorting
                if (key === 'name') return a.name.localeCompare(b.name) * dir;
                if (key === 'agents') return (b.agents.length - a.agents.length) * dir; // Sort by agent count
                
                return (valB - valA) * dir;
            });
            renderTable();
        }

        function renderTable() {
            const tbody = document.getElementById('tableBody');
            const theadRow = document.getElementById('headerRow');
            
            // Re-render Headers in correct order
            theadRow.innerHTML = '';
            columns.forEach(colKey => {
                const th = document.createElement('th');
                th.draggable = true;
                th.dataset.key = colKey;
                th.innerText = colKey.toUpperCase();
                th.onclick = () => sortData(colKey);
                
                // Add Arrow
                if (sortState.key === colKey) {
                    th.innerText += sortState.dir === 'desc' ? ' ▼' : ' ▲';
                }

                // Add Drag Events
                addHeaderDragEvents(th);
                
                // Add Specific Classes
                if(colKey === 'name') th.className = 'cell-player';
                if(colKey === 'agents') th.className = 'cell-agents';
                
                theadRow.appendChild(th);
            });

            // Re-render Body
            let html = '';
            playersData.forEach(p => {
                html += '<tr>';
                columns.forEach(colKey => {
                    let cellContent = '';
                    let cellStyle = '';
                    let cellClass = '';

                    if (colKey === 'name') {
                        cellContent = `
                            <div>
                                <a href="players/${p.name}.html" class="text-blue-600 font-bold hover:underline">${p.name}</a>
                                <span class="cell-team">${p.team}</span>
                            </div>`;
                        cellClass = 'cell-player';
                    } else if (colKey === 'agents') {
                        const agentsHtml = p.agents.map(a => `<img src="img/agents/${a}.png" class="agent-icon" title="${a}">`).join('');
                        cellContent = `<div class="agent-container">${agentsHtml}</div>`;
                        cellClass = 'cell-agents';
                    } else {
                        // Stat Cell
                        const val = p[colKey];
                        // Apply suffixes if needed (HS%, KAST%)
                        const displayVal = (colKey === 'kast' || colKey === 'hs') ? val + '%' : val;
                        // Apply Colors
                        cellStyle = getColorStyle(colKey, val);
                        cellContent = displayVal;
                        // Bold specific stats
                        if (['rating', 'k', 'kd'].includes(colKey)) {
                            cellContent = `<b>${displayVal}</b>`;
                        }
                    }

                    html += `<td class="${cellClass}" ${cellStyle}>${cellContent}</td>`;
                });
                html += '</tr>';
            });
            tbody.innerHTML = html;
        }

        // --- Column Drag Logic ---
        let dragSrcCol = null;

        function addHeaderDragEvents(th) {
            th.addEventListener('dragstart', handleHeaderDragStart);
            th.addEventListener('dragenter', handleHeaderDragEnter);
            th.addEventListener('dragover', handleHeaderDragOver);
            th.addEventListener('dragleave', handleHeaderDragLeave);
            th.addEventListener('drop', handleHeaderDrop);
            th.addEventListener('dragend', handleHeaderDragEnd);
        }

        function handleHeaderDragStart(e) {
            this.classList.add('dragging');
            dragSrcCol = this.dataset.key;
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleHeaderDragOver(e) {
            if (e.preventDefault) e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleHeaderDragEnter(e) {
            if (this.dataset.key !== dragSrcCol) {
                this.classList.add('drag-over');
            }
        }

        function handleHeaderDragLeave(e) {
            this.classList.remove('drag-over');
        }

        function handleHeaderDrop(e) {
            if (e.stopPropagation) e.stopPropagation();
            this.classList.remove('drag-over');
            
            const targetCol = this.dataset.key;

            if (dragSrcCol !== targetCol) {
                // Reorder 'columns' array
                const srcIdx = columns.indexOf(dragSrcCol);
                const targetIdx = columns.indexOf(targetCol);

                if (srcIdx > -1 && targetIdx > -1) {
                    // Remove src
                    columns.splice(srcIdx, 1);
                    // Insert at target
                    columns.splice(targetIdx, 0, dragSrcCol);
                    
                    renderTable(); // Re-render table with new column order
                }
            }
            return false;
        }

        function handleHeaderDragEnd(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('th').forEach(th => th.classList.remove('drag-over'));
        }

        initStats();
        renderTable(); // Initial Render
    </script>
</body>
</html>